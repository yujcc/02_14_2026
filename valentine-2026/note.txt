assets i should use
    icons (use phosphor):
        heart
        macOS folder
        playbutton
        reload
        music
        ...

    colors:    
        background:#FFF5F7
        primay container: #FFD1DC
        secondary: #b8c0ff
        accent/button: #F85A11
        text: #4A3737
    
    background:
        add a "dot grid" to the background
    
    window container:
        macOS style

    typography:
        header: cherry bomb one
        body: space mono

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Cherry+Bomb+One&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
       
       .cherry-bomb-one-regular {
            font-family: "Cherry Bomb One", system-ui;
            font-weight: 400;
            font-style: normal;
        }
                
        .space-mono-regular {
        font-family: "Space Mono", monospace;
        font-weight: 400;
        font-style: normal;
        }

        .space-mono-bold {
        font-family: "Space Mono", monospace;
        font-weight: 700;
        font-style: normal;
        }

        .space-mono-regular-italic {
        font-family: "Space Mono", monospace;
        font-weight: 400;
        font-style: italic;
        }

        .space-mono-bold-italic {
        font-family: "Space Mono", monospace;
        font-weight: 700;
        font-style: italic;
        }

    UI elements:
        neo-brutalism light (fit the color palette)
        https://www.neobrutalism.dev/docs/installation#install-manually

        Hard Shadows: Instead of soft, blurry CSS shadows, use solid offsets.
            CSS Tip: box-shadow: 5px 5px 0px #FF85A1;

        thick borders:
            Use 2px or 3px solid borders in a slightly darker pink or cocoa brown
        
        Rounded Corners: 
            Use a high border-radius (20px+) to keep it "kawaii" and friendly.

        cursor:
            custom CSS cursor like a small pink heart

    implementation check:
        Keep the "Minimal" part of your goal by using White Space. Just because it's kawaii doesn't mean every corner needs a sticker!
        
        Add one or two small pixel-art hearts or stars
        
        Micro-interactions: Add a "squish" effect when buttons are clicked (scale down to 0.95)  

        placeholders to insert assets later

        /*
:root {
    --bg: #0f1117;
    --primary: #b8c0ff;
    --secondary: #ffd6e0;
    --accent: #caffbf;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    background: var(--bg);
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont;
    touch-action: none;
}

canvas {
    display: block;
}

/* Mobile-friendly floating controls *
#controls {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    transition: opacity 0.3s ease;
}

#controls:active,
#controls:focus-within {
    opacity: 1;
}

input[type="range"] {
    width: 200px;
    max-width: 280px;
    accent-color: var(--primary);
}
*/

<!--<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta 
        name="viewport" 
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>02-14-2026</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Minimal controls (hidden by default) --
     <div id="controls">
        <input type="range" min="0" max="1" value="0.5" step="0.001" id="param">
    </div>

    <script src="main.js"></script>
</body>
</html> -->

/*
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let width, height, centerX, centerY;
let dpr = window.devicePixelRatio || 1;

// Smooth resize (for phones)
function resize() {
    dpr = window.devicePixelRatio || 1;

    width = window.innerWidth;
    height = window.innerHeight;

    canvas.width = width * dpr;
    canvas.height = window.innerHeight * dpr;
    
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
    
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    
    centerX = width / 2;
    centerY = height / 2;
}

window.addEventListener("resize", resize);
resize();

// touch interaction
let touchInfluence = 0;

window.addEventListener("touchstart", () => {
    touchInfluence = 1;
})

window.addEventListener("touchend", () => {
    touchInfluence = 0;
})

// // linear interpolation
// function lerp(a, b, t) {
//     return a + (b - a) * t;
// }

// particle / trajectory placeholder
// Chaos Variables
// Logistic parameters
let r = 3.9;
let epsilon = 0.0;          // coupling strength
let epsilonTarget = 0.35;   // final synchronization level

// Initial conditions (Very close but not identical)
let x = 0.500000;
let y = 0.500001;

let t= 0;
const isMobile= window.innerWidth < 768;
const iterations = isMobile ? 150 : 250;

// logistic map function
function logistic(z) {
    return r * z * (1 - z);
}

function draw() {

    // soft fade for trail persistence
    ctx.fillStyle = "rgba(15,17,23, 0.08)";
    ctx.fillRect(0, 0, width, height);

    // slowly increase coupling
    epsilon += 0.0005;
    if (epsilon > epsilonTarget) epsilon = epsilonTarget;
    
    let tempX = x;
    let tempY = y;

    ctx.beginPath();

    for (let i = 0; i < iterations; i++) {

        // coupled logistic update
        const fx = logistic(tempX);
        const fy = logistic(tempY);
        
        const nextX = (1 - epsilon) * fx + epsilon * fy;
        const nextY = (1 - epsilon) * fy + epsilon * fx;
        
        tempX = nextX;
        tempY = nextY;

        // map values to screen
        const drawX1 = centerX - 200 + tempX * 400;
        const drawY1 = centerY + Math.sin(i * 0.1) * 80;

        const drawX2 = centerX + 200 + tempY * 400;
        const drawY2 = centerY + Math.cos(i * 0.1) * 80;

        // first trajectory
        ctx.fillStyle = "rgba(184, 192, 255, 0.7)";
        ctx.fillRect(drawX1, drawY1, 1.5, 1.5);

        // second trajectory
        ctx.fillStyle = "rgba(255, 214, 224, 0.7)";
        ctx.fillRect(drawX2, drawY2, 1.5, 1.5);
    }

    // update global state
    x = tempX;
    y = tempY;

    t += 0.01;

    requestAnimationFrame(draw);
}

draw();

// Parameter control
const slider = document.getElementById("param");

slider.addEventListener("input", e => {
    // placeholder for chaos parameters
    //later: coupling strength, r value, etc.
});
*/